\chapter{Risultati}
\label{cap:risultati}
In questo capitolo verranno riportati e riassunti i risultati descritti negli esperimenti del Capitolo~\ref{cap:esperimenti}. L'obiettivo è capire brevemente quali sono stati gli approcci tentati e i problemi riscontrati durante lo svolgimento del lavoro.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Lunghezza tracce}
In un primo momento sono stati inseriti all'interno del representation language, oltre ai predicati numerici di base che Numsynth ci mette a disposizione, solamente i predicati che compaiono nei log (i.e., \textit{release}, \textit{complete}, \textit{execute} e \textit{finish}). In questo modo abbiamo visto, tramite gli esperimenti descritti dalla Sezione~\ref{sec:primo-approccio} alla Sezione~\ref{sec:event_task_chunk}, che il sistema tenta di spiegare il successo di una traccia solamente tramite la sua lunghezza.

Anche tentando un approccio diverso come spiegare il fallimento invece che il successo, come fatto nella Sezione~\ref{sec:posNeg-inversion}, il risultato non è cambiato.

Questo testimonia il fatto che i soli predicati usati non sono sufficienti al sistema per ottenere un risultato interessante. Infatti eliminando la possibilità di spiegare il successo tramite la moltiplicazione, cioè tramite il predicato \textit{mult}, il sistema non restituisce nessuna regola che abbia una buona accuracy.

Questo risultato non cambia se, come fatto per gli esperimenti nelle Sezioni~\ref{sec:event_task_chunk}, introduciamo predicati che descrivono l'evento e l'ID del task e del chunk che hanno generato, lasciando solo la traccia e il tempo come variabile.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tempi di esecuzione dei chunk}
Utilizzando un taskset di cui conosciamo il motivo del fallimento, siamo riusciti a ottenere i risultati sperati introducendo un predicato che era fondamentale perché il sistema arrivasse alla soluzione corretta. Il predicato in questione è quello relativo al tempo di esecuzione dei chunk di ogni task.

Una volta arrivati alla soluzione corretta su questo taskset, è stata valutata la gestione della complessità del sistema. Abbiamo visto che Numsynth ha difficoltà quando il numero di tracce aumenta, ma soprattutto soffre quando aumenta il numero di tracce da spiegare.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Isolamento dei predicati corretti}
Nell'esperimento descritto nella Sezione~\ref{subsec:preempt} abbiamo visto che introducendo il predicato \textit{preempt}, che indica quando un task subisce preemption da uno a priorità maggiore, il sistema riesce a trovare correttamente la soluzione, capendo comunque che quel predicato non è necessario.

Per arrivare a questo risultato non era necessario l'aggiunta di questo predicato in realtà, visto che anche negli esperimenti precedenti il sistema aveva ignorato altri predicati, come ad esempio il tempo di inizio e fine dell'esecuzione di task.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Taskset complesso da spiegare}
Abbiamo fatto un esperimento dove la spiegazione del fallimento delle tracce non era banale da capire. Nella Sezione~\ref{sec:unknown} abbiamo notato come il sistema non riesca a trovare una soluzione.