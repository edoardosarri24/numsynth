\chapter{Esperimenti}
Dopo aver eseguito una prima fase di analisi nel Capitolo~\ref{cap:analisi}, adesso andiamo a descrivere gli esperimenti e i risultati a cui questi portano. Di rilievo sarà la ì descrizione del representation bias.

\myskip

Quando si esegue un esperimento è necessario, oltre ad avere a disposizione il file di log \textit{trace.log}, definire solo il representation bias. È stato infatti pensato uno script, che dorà essere modificato in base all'esperimento e trovarsi nella cartella, che legge il file di log e definisce i file tipici di Popper (e quindi di Numsynth) \textit{bk.pl} e \textit{exs.pl} necessarie per il sistema.

Una volta ch abbiamo definito una cartella per l'esperimento contenente un file \textit{bias.pl} e uno di log \textit{trace.log}, possiamo lancaire l'esperimento dalla root directory con \texttt{./numsynth.sh <folder-name>}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Primo approccio}
Il primo approccio tentato è stato il più semplice possibile: abbiamo inserito all'interno del representation bias solo quei predicati che rappresentano ciò che i log del simulatore di taskset mostra. Questi nello specifico sono: rilascio e completmento di un task; inizio e fine dell'esecuzione di un chunk. Nella cartella \textit{my-experiments} questo esperimento è \href{https://github.com/edoardosarri24/numsynth/tree/main/my-experiments/1-start}{start}.

In questo modo stiamo chiedendo al sistema di spiegarci il fallimento o il successo della traccia su cui facciamo inferenza solamente tramite questi predicati. Sarà poi Numsynth a cercare di trovare delle relazioni, anche numeriche, tra chunk e task per coprire il maggior numero di esempi positivi e non coprire nessuno di quelli positivi.

\subsection{Modello}
Ogni traccia in questo esperimento ha una durata di massimo 100ms e sono state generate 100 tracce, di cui 76 hanno terminato con successo e 24 fallendo.

\myskip

Il modello usato per questo esperimento, essendo il primo, è stato semplice e forse banale. È stato usato Rate Monotonic (RM) come algorimto di scheduling e il taskset ha queste caratteristriche:
\begin{itemize}
    \item Task1: periodo 3ms; deadline relativa 3ms; chunk1 con execution time campionato da un ConstantSampler con parametro 1ms; chunk2 con execution time campionato da un UniformSampler con parametri 0.5ms e 1.1.
    \item Task2: periodo 5ms; deadline relativa 5ms; chunk1 con execution time campionato da un ConstantSampler con parametro 1ms.
\end{itemize}

Volevamo ottenere un taskset che fosse facile da comprendere. Una traccia dovrebbe avere sempre successo tranne quando il secondo chunk del primo task (i.e., chunk1.2) campio un valore superiore a 1. Essendo sotto RM , in questo caso al task2 non rimarebbe abbastanza tempo per eseguire entro la propria deadline.

\subsection{Risultati}
I risultati, che possiamo osservare nel file \href{https://github.com/edoardosarri24/numsynth/tree/main/my-experiments/1-start/result.txt}{result.txt}, mostrano la semplicità del modello scelto per questo esperimento.
\begin{itemize}
    \item Il tempo di addestramento è di circa 10s.
    \item La precision e la recall sono entrambe massime e pari a 1.
    \item La soluzione è composta da quattro letterali: \texttt{failure(A):- finish(A,F,C,B), \allowbreak mult(F,96,D),execute(A,D,C,B)}.
\end{itemize}

\myskip

Il risultato mette in evidenza come una traccia ha successo se esiste un chunk che inizia a tempo \textit{D} e finisce a tempo \textit{F}, dove $D=F\cdot96$.

Il problema di questo risultato, supponendo la sua correttezza, è il suo overfitting: non bagliando niente, probabilmente non riesce a generalizzare bene su tracce non viste.

\subsection{Generalizzazione}
Per capire se possiamo risolvere il problema dell'overfitting abbiamo eseguito lo stesso espeirmento allenando il sistema su più tracce, in qeusto caso 1000.

I risultati sono molto simili:
\begin{itemize}
    \item Il tempo di addestramento è di circa 3m32s. Questo ci fa capire come la dimensione del dataset incide molto sui tempi di training.
    \item La precsion e la recall sono sempre massime.
    \item La solzione proposta è molto simile a quella precedente: \\ \texttt{failure(A):- finish(A,E,B,D), execute(A,F,B,D),mult(E,96,F)}
\end{itemize}

\myskip

Possiamo trarre esattamente le stesse conclusioni anche per questo tipo di esempio.